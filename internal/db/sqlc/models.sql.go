// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: models.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLlmProviders = `-- name: CountLlmProviders :one
SELECT COUNT(*) FROM llm_providers
`

func (q *Queries) CountLlmProviders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLlmProviders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLlmProvidersByClientType = `-- name: CountLlmProvidersByClientType :one
SELECT COUNT(*) FROM llm_providers WHERE client_type = $1
`

func (q *Queries) CountLlmProvidersByClientType(ctx context.Context, clientType string) (int64, error) {
	row := q.db.QueryRow(ctx, countLlmProvidersByClientType, clientType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countModels = `-- name: CountModels :one
SELECT COUNT(*) FROM models
`

func (q *Queries) CountModels(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countModels)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countModelsByType = `-- name: CountModelsByType :one
SELECT COUNT(*) FROM models WHERE type = $1
`

func (q *Queries) CountModelsByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRow(ctx, countModelsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLlmProvider = `-- name: CreateLlmProvider :one
INSERT INTO llm_providers (name, client_type, base_url, api_key, metadata)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, name, client_type, base_url, api_key, metadata, created_at, updated_at
`

type CreateLlmProviderParams struct {
	Name       string `json:"name"`
	ClientType string `json:"client_type"`
	BaseUrl    string `json:"base_url"`
	ApiKey     string `json:"api_key"`
	Metadata   []byte `json:"metadata"`
}

func (q *Queries) CreateLlmProvider(ctx context.Context, arg CreateLlmProviderParams) (LlmProvider, error) {
	row := q.db.QueryRow(ctx, createLlmProvider,
		arg.Name,
		arg.ClientType,
		arg.BaseUrl,
		arg.ApiKey,
		arg.Metadata,
	)
	var i LlmProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientType,
		&i.BaseUrl,
		&i.ApiKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createModel = `-- name: CreateModel :one
INSERT INTO models (model_id, name, llm_provider_id, dimensions, input_modalities, type)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
RETURNING id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at
`

type CreateModelParams struct {
	ModelID         string      `json:"model_id"`
	Name            pgtype.Text `json:"name"`
	LlmProviderID   pgtype.UUID `json:"llm_provider_id"`
	Dimensions      pgtype.Int4 `json:"dimensions"`
	InputModalities []string    `json:"input_modalities"`
	Type            string      `json:"type"`
}

func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (Model, error) {
	row := q.db.QueryRow(ctx, createModel,
		arg.ModelID,
		arg.Name,
		arg.LlmProviderID,
		arg.Dimensions,
		arg.InputModalities,
		arg.Type,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.Name,
		&i.LlmProviderID,
		&i.Dimensions,
		&i.InputModalities,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createModelVariant = `-- name: CreateModelVariant :one
INSERT INTO model_variants (model_uuid, variant_id, weight, metadata)
VALUES (
  $1,
  $2,
  $3,
  $4
)
RETURNING id, model_uuid, variant_id, weight, metadata, created_at, updated_at
`

type CreateModelVariantParams struct {
	ModelUuid pgtype.UUID `json:"model_uuid"`
	VariantID string      `json:"variant_id"`
	Weight    int32       `json:"weight"`
	Metadata  []byte      `json:"metadata"`
}

func (q *Queries) CreateModelVariant(ctx context.Context, arg CreateModelVariantParams) (ModelVariant, error) {
	row := q.db.QueryRow(ctx, createModelVariant,
		arg.ModelUuid,
		arg.VariantID,
		arg.Weight,
		arg.Metadata,
	)
	var i ModelVariant
	err := row.Scan(
		&i.ID,
		&i.ModelUuid,
		&i.VariantID,
		&i.Weight,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLlmProvider = `-- name: DeleteLlmProvider :exec
DELETE FROM llm_providers WHERE id = $1
`

func (q *Queries) DeleteLlmProvider(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLlmProvider, id)
	return err
}

const deleteModel = `-- name: DeleteModel :exec
DELETE FROM models WHERE id = $1
`

func (q *Queries) DeleteModel(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteModel, id)
	return err
}

const deleteModelByModelID = `-- name: DeleteModelByModelID :exec
DELETE FROM models WHERE model_id = $1
`

func (q *Queries) DeleteModelByModelID(ctx context.Context, modelID string) error {
	_, err := q.db.Exec(ctx, deleteModelByModelID, modelID)
	return err
}

const getLlmProviderByID = `-- name: GetLlmProviderByID :one
SELECT id, name, client_type, base_url, api_key, metadata, created_at, updated_at FROM llm_providers WHERE id = $1
`

func (q *Queries) GetLlmProviderByID(ctx context.Context, id pgtype.UUID) (LlmProvider, error) {
	row := q.db.QueryRow(ctx, getLlmProviderByID, id)
	var i LlmProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientType,
		&i.BaseUrl,
		&i.ApiKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLlmProviderByName = `-- name: GetLlmProviderByName :one
SELECT id, name, client_type, base_url, api_key, metadata, created_at, updated_at FROM llm_providers WHERE name = $1
`

func (q *Queries) GetLlmProviderByName(ctx context.Context, name string) (LlmProvider, error) {
	row := q.db.QueryRow(ctx, getLlmProviderByName, name)
	var i LlmProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientType,
		&i.BaseUrl,
		&i.ApiKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModelByID = `-- name: GetModelByID :one
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models WHERE id = $1
`

func (q *Queries) GetModelByID(ctx context.Context, id pgtype.UUID) (Model, error) {
	row := q.db.QueryRow(ctx, getModelByID, id)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.Name,
		&i.LlmProviderID,
		&i.Dimensions,
		&i.InputModalities,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModelByModelID = `-- name: GetModelByModelID :one
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models WHERE model_id = $1
`

func (q *Queries) GetModelByModelID(ctx context.Context, modelID string) (Model, error) {
	row := q.db.QueryRow(ctx, getModelByModelID, modelID)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.Name,
		&i.LlmProviderID,
		&i.Dimensions,
		&i.InputModalities,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLlmProviders = `-- name: ListLlmProviders :many
SELECT id, name, client_type, base_url, api_key, metadata, created_at, updated_at FROM llm_providers
ORDER BY created_at DESC
`

func (q *Queries) ListLlmProviders(ctx context.Context) ([]LlmProvider, error) {
	rows, err := q.db.Query(ctx, listLlmProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmProvider
	for rows.Next() {
		var i LlmProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ClientType,
			&i.BaseUrl,
			&i.ApiKey,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLlmProvidersByClientType = `-- name: ListLlmProvidersByClientType :many
SELECT id, name, client_type, base_url, api_key, metadata, created_at, updated_at FROM llm_providers
WHERE client_type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLlmProvidersByClientType(ctx context.Context, clientType string) ([]LlmProvider, error) {
	rows, err := q.db.Query(ctx, listLlmProvidersByClientType, clientType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmProvider
	for rows.Next() {
		var i LlmProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ClientType,
			&i.BaseUrl,
			&i.ApiKey,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelVariantsByModelUUID = `-- name: ListModelVariantsByModelUUID :many
SELECT id, model_uuid, variant_id, weight, metadata, created_at, updated_at FROM model_variants
WHERE model_uuid = $1
ORDER BY weight DESC, created_at DESC
`

func (q *Queries) ListModelVariantsByModelUUID(ctx context.Context, modelUuid pgtype.UUID) ([]ModelVariant, error) {
	rows, err := q.db.Query(ctx, listModelVariantsByModelUUID, modelUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModelVariant
	for rows.Next() {
		var i ModelVariant
		if err := rows.Scan(
			&i.ID,
			&i.ModelUuid,
			&i.VariantID,
			&i.Weight,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModels = `-- name: ListModels :many
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models
ORDER BY created_at DESC
`

func (q *Queries) ListModels(ctx context.Context) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.Name,
			&i.LlmProviderID,
			&i.Dimensions,
			&i.InputModalities,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelsByClientType = `-- name: ListModelsByClientType :many
SELECT m.id, m.model_id, m.name, m.llm_provider_id, m.dimensions, m.input_modalities, m.type, m.created_at, m.updated_at FROM models AS m
JOIN llm_providers AS p ON p.id = m.llm_provider_id
WHERE p.client_type = $1
ORDER BY m.created_at DESC
`

func (q *Queries) ListModelsByClientType(ctx context.Context, clientType string) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModelsByClientType, clientType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.Name,
			&i.LlmProviderID,
			&i.Dimensions,
			&i.InputModalities,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelsByProviderID = `-- name: ListModelsByProviderID :many
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models
WHERE llm_provider_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListModelsByProviderID(ctx context.Context, llmProviderID pgtype.UUID) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModelsByProviderID, llmProviderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.Name,
			&i.LlmProviderID,
			&i.Dimensions,
			&i.InputModalities,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelsByProviderIDAndType = `-- name: ListModelsByProviderIDAndType :many
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models
WHERE llm_provider_id = $1
  AND type = $2
ORDER BY created_at DESC
`

type ListModelsByProviderIDAndTypeParams struct {
	LlmProviderID pgtype.UUID `json:"llm_provider_id"`
	Type          string      `json:"type"`
}

func (q *Queries) ListModelsByProviderIDAndType(ctx context.Context, arg ListModelsByProviderIDAndTypeParams) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModelsByProviderIDAndType, arg.LlmProviderID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.Name,
			&i.LlmProviderID,
			&i.Dimensions,
			&i.InputModalities,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelsByType = `-- name: ListModelsByType :many
SELECT id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at FROM models
WHERE type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListModelsByType(ctx context.Context, type_ string) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModelsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.Name,
			&i.LlmProviderID,
			&i.Dimensions,
			&i.InputModalities,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLlmProvider = `-- name: UpdateLlmProvider :one
UPDATE llm_providers
SET
  name = $1,
  client_type = $2,
  base_url = $3,
  api_key = $4,
  metadata = $5,
  updated_at = now()
WHERE id = $6
RETURNING id, name, client_type, base_url, api_key, metadata, created_at, updated_at
`

type UpdateLlmProviderParams struct {
	Name       string      `json:"name"`
	ClientType string      `json:"client_type"`
	BaseUrl    string      `json:"base_url"`
	ApiKey     string      `json:"api_key"`
	Metadata   []byte      `json:"metadata"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateLlmProvider(ctx context.Context, arg UpdateLlmProviderParams) (LlmProvider, error) {
	row := q.db.QueryRow(ctx, updateLlmProvider,
		arg.Name,
		arg.ClientType,
		arg.BaseUrl,
		arg.ApiKey,
		arg.Metadata,
		arg.ID,
	)
	var i LlmProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ClientType,
		&i.BaseUrl,
		&i.ApiKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateModel = `-- name: UpdateModel :one
UPDATE models
SET
  name = $1,
  llm_provider_id = $2,
  dimensions = $3,
  input_modalities = $4,
  type = $5,
  updated_at = now()
WHERE id = $6
RETURNING id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at
`

type UpdateModelParams struct {
	Name            pgtype.Text `json:"name"`
	LlmProviderID   pgtype.UUID `json:"llm_provider_id"`
	Dimensions      pgtype.Int4 `json:"dimensions"`
	InputModalities []string    `json:"input_modalities"`
	Type            string      `json:"type"`
	ID              pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateModel(ctx context.Context, arg UpdateModelParams) (Model, error) {
	row := q.db.QueryRow(ctx, updateModel,
		arg.Name,
		arg.LlmProviderID,
		arg.Dimensions,
		arg.InputModalities,
		arg.Type,
		arg.ID,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.Name,
		&i.LlmProviderID,
		&i.Dimensions,
		&i.InputModalities,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateModelByModelID = `-- name: UpdateModelByModelID :one
UPDATE models
SET
  model_id = $1,
  name = $2,
  llm_provider_id = $3,
  dimensions = $4,
  input_modalities = $5,
  type = $6,
  updated_at = now()
WHERE model_id = $7
RETURNING id, model_id, name, llm_provider_id, dimensions, input_modalities, type, created_at, updated_at
`

type UpdateModelByModelIDParams struct {
	NewModelID      string      `json:"new_model_id"`
	Name            pgtype.Text `json:"name"`
	LlmProviderID   pgtype.UUID `json:"llm_provider_id"`
	Dimensions      pgtype.Int4 `json:"dimensions"`
	InputModalities []string    `json:"input_modalities"`
	Type            string      `json:"type"`
	ModelID         string      `json:"model_id"`
}

func (q *Queries) UpdateModelByModelID(ctx context.Context, arg UpdateModelByModelIDParams) (Model, error) {
	row := q.db.QueryRow(ctx, updateModelByModelID,
		arg.NewModelID,
		arg.Name,
		arg.LlmProviderID,
		arg.Dimensions,
		arg.InputModalities,
		arg.Type,
		arg.ModelID,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.Name,
		&i.LlmProviderID,
		&i.Dimensions,
		&i.InputModalities,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
