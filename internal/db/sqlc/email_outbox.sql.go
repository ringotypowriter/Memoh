// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_outbox.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEmailOutboxByBot = `-- name: CountEmailOutboxByBot :one
SELECT count(*) FROM email_outbox
WHERE bot_id = $1
`

func (q *Queries) CountEmailOutboxByBot(ctx context.Context, botID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEmailOutboxByBot, botID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmailOutbox = `-- name: CreateEmailOutbox :one
INSERT INTO email_outbox (provider_id, bot_id, from_address, to_addresses, subject, body_text, body_html, attachments, status)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
RETURNING id, provider_id, bot_id, message_id, from_address, to_addresses, subject, body_text, body_html, attachments, status, error, sent_at, created_at
`

type CreateEmailOutboxParams struct {
	ProviderID  pgtype.UUID `json:"provider_id"`
	BotID       pgtype.UUID `json:"bot_id"`
	FromAddress string      `json:"from_address"`
	ToAddresses []byte      `json:"to_addresses"`
	Subject     string      `json:"subject"`
	BodyText    string      `json:"body_text"`
	BodyHtml    string      `json:"body_html"`
	Attachments []byte      `json:"attachments"`
	Status      string      `json:"status"`
}

func (q *Queries) CreateEmailOutbox(ctx context.Context, arg CreateEmailOutboxParams) (EmailOutbox, error) {
	row := q.db.QueryRow(ctx, createEmailOutbox,
		arg.ProviderID,
		arg.BotID,
		arg.FromAddress,
		arg.ToAddresses,
		arg.Subject,
		arg.BodyText,
		arg.BodyHtml,
		arg.Attachments,
		arg.Status,
	)
	var i EmailOutbox
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.BotID,
		&i.MessageID,
		&i.FromAddress,
		&i.ToAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.Attachments,
		&i.Status,
		&i.Error,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const getEmailOutboxByID = `-- name: GetEmailOutboxByID :one
SELECT id, provider_id, bot_id, message_id, from_address, to_addresses, subject, body_text, body_html, attachments, status, error, sent_at, created_at FROM email_outbox WHERE id = $1
`

func (q *Queries) GetEmailOutboxByID(ctx context.Context, id pgtype.UUID) (EmailOutbox, error) {
	row := q.db.QueryRow(ctx, getEmailOutboxByID, id)
	var i EmailOutbox
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.BotID,
		&i.MessageID,
		&i.FromAddress,
		&i.ToAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.Attachments,
		&i.Status,
		&i.Error,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const listEmailOutboxByBot = `-- name: ListEmailOutboxByBot :many
SELECT id, provider_id, bot_id, message_id, from_address, to_addresses, subject, body_text, body_html, attachments, status, error, sent_at, created_at FROM email_outbox
WHERE bot_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListEmailOutboxByBotParams struct {
	BotID pgtype.UUID `json:"bot_id"`
	Off   int32       `json:"off"`
	Lim   int32       `json:"lim"`
}

func (q *Queries) ListEmailOutboxByBot(ctx context.Context, arg ListEmailOutboxByBotParams) ([]EmailOutbox, error) {
	rows, err := q.db.Query(ctx, listEmailOutboxByBot, arg.BotID, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailOutbox
	for rows.Next() {
		var i EmailOutbox
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.BotID,
			&i.MessageID,
			&i.FromAddress,
			&i.ToAddresses,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.Attachments,
			&i.Status,
			&i.Error,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailOutboxFailed = `-- name: UpdateEmailOutboxFailed :exec
UPDATE email_outbox
SET status = 'failed', error = $1
WHERE id = $2
`

type UpdateEmailOutboxFailedParams struct {
	Error string      `json:"error"`
	ID    pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateEmailOutboxFailed(ctx context.Context, arg UpdateEmailOutboxFailedParams) error {
	_, err := q.db.Exec(ctx, updateEmailOutboxFailed, arg.Error, arg.ID)
	return err
}

const updateEmailOutboxSent = `-- name: UpdateEmailOutboxSent :exec
UPDATE email_outbox
SET message_id = $1, status = 'sent', sent_at = now()
WHERE id = $2
`

type UpdateEmailOutboxSentParams struct {
	MessageID string      `json:"message_id"`
	ID        pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateEmailOutboxSent(ctx context.Context, arg UpdateEmailOutboxSentParams) error {
	_, err := q.db.Exec(ctx, updateEmailOutboxSent, arg.MessageID, arg.ID)
	return err
}
